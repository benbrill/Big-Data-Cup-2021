# -*- coding: utf-8 -*-
"""Big Data Cup

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YnyFpCKz8UV0ZpuYglyuw6-FYP9beZRi

#### Basic Info
- [Site Info]( https://www.stathletes.com/big-data-cup/)
-[Github Repository](https://github.com/bigdatacup/Big-Data-Cup-2021)
-[Hockey Graphs Inspo](https://hockey-graphs.com/category/passing-data/)

## Plans/Ideas

### Zone Entry and Scoring Chances
1. Code scoring chance and high danger scoring chance function
2. Generate new chunk function to determine what happens in the chunk after a zone entry
3. For different projects
  - Erie 
    - Compare Otter's performance against teams that are good at defending certain types of zone entries
  - NWHL
    - can rank efficencies across the league

### Breakouts
Analyze different breakout patterns across teams. See where passes originate from. Can help with forecheck and defense

### Player ratings based on sequence efficency

### Good or Bad Penalties
Is it better to take a penalty or a high danger chance
"""

# bread and butter libraries
import numpy as np
import pandas as pd

"""# Load Data"""

olympic = pd.read_csv("https://raw.githubusercontent.com/bigdatacup/Big-Data-Cup-2021/main/hackathon_womens.csv")
olympic.columns = ['gameDate', 'home', 'away', 'period', 'clock',
       'homeSkaters', 'awaySkaters', 'homeGoals',
       'awayGoals', 'team', 'player', 'event', 'X',
       'Y', 'd1', 'd2', 'd3', 'd4',
       'player2', 'X2', 'Y2']
olympic

nwhl = pd.read_csv("https://raw.githubusercontent.com/bigdatacup/Big-Data-Cup-2021/main/hackathon_nwhl.csv")
nwhl.columns = ['gameDate', 'home', 'away', 'period', 'clock',
       'homeSkaters', 'awaySkaters', 'homeGoals',
       'awayGoals', 'team', 'player', 'event', 'X',
       'Y', 'd1', 'd2', 'd3', 'd4',
       'player2', 'X2', 'Y2']
nwhl

"""## Classification Functions

### Plot Ice
"""

from matplotlib import pyplot as plt
import matplotlib.image as mpimg
import seaborn as sns

def plotIce():
  """
  This function plots an NHL size sheet of Ice
  """
  img = mpimg.imread('/content/2640570_orig.png')
  fig, ax = plt.subplots(figsize=(15,20))
  imgplot = ax.imshow(img, extent=[-100,100,-42.5,42.5])

  highDang = np.array([(-89,-9),(-69,-22),(-54,-22),(-54,-9),(-44,-9),(-44,9),(-54,9),(-54,22),(-69,22),(-89,9),(-69,9),(-69,-9)])

  circ = plt.Rectangle((69,-9), 20, 18, color="red", alpha = 0.3)
  tri = plt.Polygon(highDang*-1, color = "yellow", alpha=0.3)
  fig.gca().add_patch(circ)
  fig.gca().add_patch(tri)
  # plt.axis(False)
  return fig, ax

"""### High Danger

#### Polygon Function
"""

# function is from geeksforgeeks

INT_MAX = 10000
 
# Given three colinear points p, q, r,  
# the function checks if point q lies 
# on line segment 'pr' 
def onSegment(p:tuple, q:tuple, r:tuple) -> bool:
     
    if ((q[0] <= max(p[0], r[0])) &
        (q[0] >= min(p[0], r[0])) &
        (q[1] <= max(p[1], r[1])) &
        (q[1] >= min(p[1], r[1]))):
        return True
         
    return False
 
# To find orientation of ordered triplet (p, q, r). 
# The function returns following values 
# 0 --> p, q and r are colinear 
# 1 --> Clockwise 
# 2 --> Counterclockwise 
def orientation(p:tuple, q:tuple, r:tuple) -> int:
     
    val = (((q[1] - p[1]) *
            (r[0] - q[0])) -
           ((q[0] - p[0]) *
            (r[1] - q[1])))
            
    if val == 0:
        return 0
    if val > 0:
        return 1 # Collinear
    else:
        return 2 # Clock or counterclock
 
def doIntersect(p1, q1, p2, q2):
     
    # Find the four orientations needed for  
    # general and special cases 
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)
 
    # General case
    if (o1 != o2) and (o3 != o4):
        return True
     
    # Special Cases 
    # p1, q1 and p2 are colinear and 
    # p2 lies on segment p1q1 
    if (o1 == 0) and (onSegment(p1, p2, q1)):
        return True
 
    # p1, q1 and p2 are colinear and 
    # q2 lies on segment p1q1 
    if (o2 == 0) and (onSegment(p1, q2, q1)):
        return True
 
    # p2, q2 and p1 are colinear and 
    # p1 lies on segment p2q2 
    if (o3 == 0) and (onSegment(p2, p1, q2)):
        return True
 
    # p2, q2 and q1 are colinear and 
    # q1 lies on segment p2q2 
    if (o4 == 0) and (onSegment(p2, q1, q2)):
        return True
 
    return False
 
# Returns true if the point p lies  
# inside the polygon[] with n vertices 
def is_inside_polygon(points:list, p:tuple) -> bool:
     
    n = len(points)
     
    # There must be at least 3 vertices
    # in polygon
    if n < 3:
        return False
         
    # Create a point for line segment
    # from p to infinite
    extreme = (INT_MAX, p[1])
    count = i = 0
     
    while True:
        next = (i + 1) % n
         
        # Check if the line segment from 'p' to  
        # 'extreme' intersects with the line  
        # segment from 'polygon[i]' to 'polygon[next]' 
        if (doIntersect(points[i],
                        points[next], 
                        p, extreme)):
                             
            # If the point 'p' is colinear with line  
            # segment 'i-next', then check if it lies  
            # on segment. If it lies, return true, otherwise false 
            if orientation(points[i], p, 
                           points[next]) == 0:
                return onSegment(points[i], p, 
                                 points[next])
                                  
            count += 1
             
        i = next
         
        if (i == 0):
            break
         
    # Return true if count is odd, false otherwise 
    return (count % 2 == 1)
# This code is contributed by Vikas Chitturi

"""### High Danger Function"""

def timetoSecs(t): 
  new = t.split(":")
  if ((int(new[1]) == 0) & (int(new[0]) == 0)):
    new = 0
  elif int(new[1]) == 0:
    new = int(new[0].lstrip('0'))*60
  elif int(new[0]) == 0:
    new = int(new[1].lstrip('0'))
  else:
    new = int(new[0].lstrip('0'))*60 + int(new[1].lstrip('0'))
  return new

def isHighDanger(x, y, ax, df):
  '''
  inputs x and y coordinates of a data frame that contains only shots and goals, 
  '''
  try:
    point = (x,y)
    score = 0
    highDang = np.array([(-89,-9),(-69,-22),(-54,-22),(-54,-9),(-44,-9),(-44,9),(-54,9),(-54,22),(-69,22),(-89,9),(-69,9),(-69,-9)])
    #find initial score based on shot location
    if is_inside_polygon(highDang*-1, point):
      score += 2
    elif is_inside_polygon([(69, -9), (69, 9), (89, 9), (89, -9)], point):
      score+= 3
    else:
      score+= 1
    # add halfpoints for traffic and for one timers

    time = timetoSecs(df.loc[ax, "clock"])
    team = df.loc[ax, "team"]

    index = ax-1
    time1 = time
    reboundFlag, rushFlag = False, False
    while (time1 < time + 4):
      # print(f"Orig time: {time}, current time: {time1}, index: {index}, og time: {df.loc[ax, 'clock']} ")
      time1 = timetoSecs(df.loc[index, "clock"])
      currentEvent = df.loc[index, "event"]
      currentTeam = df.loc[index, "team"]

      # check for rebounds
      if (currentTeam == team and reboundFlag != True):
        if (currentEvent == "Shot" or currentEvent == "Goal"):
          score += 1
          df.loc[ax, 'isRebound'] = 1
          reboundFlag = True
      
      #check for rush
      # print(df.loc[index, "X"])
      if ((df.loc[index, "X"] <= 24) and rushFlag != True):
        score += 1
        df.loc[ax, 'isRush'] = 1
        rushFlag = True
    
      # stop if either rebound and rush is True, exhausting all possibilities
      if reboundFlag and rushFlag:
        break
      
      index = index - 1
  except KeyError:
    return 0
  return score

"""### Determine HighLow or Lateral"""

def isLat(X, Y, X2, Y2):
  if ((X >= 54) & (Y <= -22) | (Y >= 22)) & ((X2 >= 54) & (Y2 <= -22) | (Y2 >= 22)) & (X >= 54):
    return 1
  else:
    return 0
def isLowHigh(X, Y, X2, Y2):
  if ((X2 <= 44) & (X2 >= 24)) & (X >= 69):
    return 1
  else:
    return 0

fig, ax = plotIce()
sns.scatterplot(x=[54], y = [-22], ax = ax)

"""### Seperate Chunks"""

def seperateChunks(df):
  print("Staring")
  sequences = []
  seq = []
  team = df.iloc[0]["team"]

  # establish empty chunkCount column

  df['chunk'], df['chunkIdx'] = np.NaN, np.NaN
  maxlen = 0
  chunkCount = 0
  itercount = 0
  # print(team)
  for index, rows in df.iterrows():
    # print(index, chunkCount)
    # print(team, rows["team"])
    if ((team != rows["team"]) | (rows['event'] == 'Faceoff Win')):
      # print("row is different team")
      sequences.append(seq)
      chunkCount += 1
      itercount = 0
      seq = []
    if len(seq) == 0:
      # print("establish new team")
      team = rows["team"]
    if team == rows["team"]:
      # print("row is same team")
      seq.append(rows.to_numpy())
    df.loc[index,'chunk'] = chunkCount
    df.loc[index,'chunkIdx'] = itercount
    itercount += 1
  return toArray(sequences) # for LTSM
  # return np.asarray(sequences, dtype=object)

def toArray(seq):
  holla = seq
  maxlen = 0
  for i in seq:
    if len(i) > maxlen:
      maxlen = len(i)
  counter = 0
  for i in holla:
    if len(i) < maxlen:
      holla[counter] = i + [[0 for i in range(21)]]*(maxlen-len(i))
    counter += 1
  return np.asarray(holla, dtype=object)

"""### Map Pass Events"""

def mapPassEvents(chunk, fig, ax):
  chunk = chunk.fillna(0)
  
  sns.scatterplot(x='X', y = 'Y', data=chunk, style='event', ax=ax, hue='xG', palette='RdBu', s = 300, alpha = 1)
  colors = {
        'Incomplete Play': 'red',
        'Play': 'blue',
        'On Net': 'green',
        'Missed': 'grey',
        'Blocked': 'firebrick'
    }
  tofP = {
      'Direct': '-',
      'Indirect': '-.',
      't': '-.',
      'f' :'--'
    }
  count = 0
  for index, play in chunk.iterrows():
    # if the iteration is the first
    if count == 0:
      count += 1
      continue
    
    # current play is not a pass
    if ((play['event'] != "Play") and (play['event'] != "Incomplete Play")):
      if ((chunk.loc[index-1].event != 'Play') and (chunk.loc[index-1].event != "Incomplete Play")): # play before is not a pass
        if (chunk.loc[index-1].event != 'Shot'):
          nopassArrow(ax, chunk.loc[index-1]['X'], chunk.loc[index-1]['Y'], play['X'], play['Y'], count)
          count += 1
        else: 
          cColor = colors[chunk.loc[index-1]['d2']]
          ctype = tofP[chunk.loc[index-1]['d3']]
          ax.plot([chunk.loc[index-1]['X'], 89], [chunk.loc[index-1]['Y'], 0], color = cColor, linestyle=ctype)
      else: # if the play before is a pass
        ax.arrow(chunk.loc[index-1]['X2'], chunk.loc[index-1]['Y2'], (play['X'] - chunk.loc[index-1]['X2']), (play['Y'] - chunk.loc[index-1]['Y2']), 
              head_width=1, linestyle = "-", color = "grey", width=0.5, alpha = 0.15,)
        midpointX = (play['X'] + chunk.loc[index-1]['X2']) / 2
        midpointY = (play['Y'] + chunk.loc[index-1]['Y2']) / 2
        ax.annotate(count, (midpointX, midpointY),)
        count += 1


    if (play['event'] == "Play") or (play['event'] == "Incomplete Play"): # if current play is a pass
      if (((chunk.loc[index-1].event == 'Play') or (chunk.loc[index-1].event == "Incomplete Play"))): # if the play before is also a pass
        nopassArrow(ax, chunk.loc[index-1]['X2'], chunk.loc[index-1]['Y2'], play['X'], play['Y'], count)
        count += 1
      else: #if current play is a pass and play before is not a pass
        nopassArrow(ax, chunk.loc[index-1]['X'], chunk.loc[index-1]['Y'], play['X'], play['Y'], count)
        count += 1

      cColor = colors[play['event']]
      ctype = tofP[play['d1']]
      ax.arrow(play['X'], play['Y'], (play['X2'] - play['X']), (play['Y2'] - play['Y']), head_width=3, linestyle = ctype, color = cColor, width=1, alpha = 0.3,)
      midpointX = (play['X'] + play['X2']) / 2
      midpointY = (play['Y'] + play['Y2']) / 2
      ax.annotate(count, (midpointX, midpointY), color = "red")
      # print(f'play now: {count}, {index}')
      count+= 1
  ax.set_title(f'Team: {play.loc["team"]}')

def nopassArrow(ax, startX, startY, endX, endY, count):
  ax.arrow(startX, startY, (endX - startX), (endY - startY), 
              head_width=1, linestyle = "-", color = "grey", width=0.5, alpha = 0.15,)
  midpointX = (startX + endX) / 2
  midpointY = (startY + endY) / 2
  ax.annotate(count, (midpointX, midpointY))

"""## Transform Data"""

data = pd.concat((nwhl, olympic)).reset_index()
data['Y'] = data['Y'] - 42.5
data['X'] = data['X'] - 100
data['Y2'] = data['Y2'] - 42.5
data['X2'] = data['X2'] - 100
data['isLat'] = data.apply(lambda x: isLat(x['X'], x['Y'], x['X2'], x['Y2']), axis = 1)
data['isLowHigh'] = data.apply(lambda x: isLowHigh(x['X'], x['Y'], x['X2'], x['Y2']), axis = 1)
data['shotQuality'] = data.loc[(data['event'] == "Shot") | (data['event'] == "Goal")].apply(lambda x: isHighDanger(x['X'],x['Y'], x.name, data), axis = 1)
data

data.iloc[48]

"""# Expected Goals"""

def distance(X,Y):
  return round(np.sqrt((89-X)**2 + (0 - Y)**2), 2)

import math
def shotAngle(X,Y):
  x0 = 89 - X
  return math.degrees(math.atan2(Y, x0))

def timeDiff(clock, series, df):
  idx = series.name
  if idx == 0:
    return 0
  return df.loc[idx - 1, 'clock'] - clock

xGData = data.copy()
xGData = xGData.drop(['gameDate', 'home', 'away', 'period', 'player', "player2", "X2", "Y2", "homeGoals", "awayGoals"], axis = 1)
xGData['shotDistance'] = xGData[(xGData['event'] == "Shot") | (xGData['event'] == "Goal")].apply(lambda x: distance(x["X"], x['Y']), axis = 1)
xGData['shotAngle'] = xGData[(xGData['event'] == "Shot") | (xGData['event'] == "Goal")].apply(lambda x: shotAngle(x["X"], x['Y']), axis = 1)
xGData['isGoal'] = xGData['event'].apply(lambda x: 1 if (x == "Goal") else 0)
xGData['clock'] = xGData['clock'].apply(timetoSecs)
xGData['timeDiff'] = xGData.apply(lambda x: timeDiff(x['clock'], x, xGData), axis = 1)
xGData # [(xGData['event'] == "Shot") | (xGData['event'] == "Goal")]

"""## Chunks for passes and goals"""

def seperatePassShotChunks(df):
  print("Staring")
  sequences = []
  seq = []
  team = df.iloc[0]["team"]

  # establish empty chunkCount column

  df['chunk'], df['chunkIdx'] = np.NaN, np.NaN
  maxlen = 0
  chunkCount = 0
  itercount = 0
  for index, rows in df.iterrows():
    if ((rows["event"] == "Shot") | (rows['event'] == "Goal")): 
      sequences.append(seq)
      df.loc[index,'chunk'] = chunkCount
      df.loc[index,'chunkIdx'] = itercount
      chunkCount += 1
      itercount = 0
      seq = []
      continue
    if ((team != rows["team"])):
      # print("row is different team")
      sequences.append(seq)
      chunkCount += 1
      itercount = 0
      seq = []
    if len(seq) == 0:
      # print("establish new team")
      team = rows["team"]
    if team == rows["team"]:
      # print("row is same team")
      seq.append(rows.to_numpy())
    df.loc[index,'chunk'] = chunkCount
    df.loc[index,'chunkIdx'] = itercount
    itercount += 1
  return toArray(sequences) # for LTSM

passShot = xGData[(xGData['event'] == "Shot") | (xGData['event'] == "Goal") | (xGData['event'] == "Play") | (xGData['event'] == "Incomplete Play")]
seperatePassShotChunks(passShot)

# chunks consisting of only passes and shots
passchunks = passShot.reset_index().set_index(['chunk', 'chunkIdx'])
passchunks

"""## Score Shots for quality of prior passes"""

np.unique(np.array(list(zip(*passchunks.index))[0]))

def countPassTypes(chunk):
  chas = np.unique(np.array(list(zip(*chunk.index))[0]))
  for index in chas:
    current = chunk.loc[index]
    current = current.fillna(0)

    try:
      shotIdx = int(current.iloc[-1].name)
    except ValueError:
      shotIdx = current.iloc[-1].name
    
    
    realIdx = current.loc[shotIdx, "index"]
    if (data.loc[realIdx, "event"] == "Shot"):
      passchunks.loc[(index, shotIdx), 'isReboundShot'] = 1
    if current.loc[shotIdx, "event"] != "Shot":
      continue
    if len(current) <= 3:
      subtract = shotIdx - (len(current) - 1)
    else:
      subtract = shotIdx - 3
    # print(current[subtract:shotIdx]['isLowHigh'])
    # find number of low high pass
    
    passchunks.loc[(index, shotIdx), 'lowHighCount'] = current[subtract:shotIdx]['isLowHigh'].sum()
    passchunks.loc[(index, shotIdx), 'latCount'] = current[subtract:shotIdx]['isLat'].sum()
    # print(passchunks.loc[(index, shotIdx), 'latCount'])

    # if (current['isLowHigh'].sum() > 0) | (current['isLat'].sum() > 0):
    #   print(index, current['isLat'].sum(), current['isLowHigh'].sum())

countPassTypes(passchunks)
# passchunks.loc[(595,5), 'latCount'] = "hate"
passchunks.loc[(593, 0), "index"]

passchunks[passchunks["event"] == "Goal"]

data[420:430]

"""### Rate shots"""

ratedShots = passchunks[(passchunks.loc[(slice(None),), "event"] == "Goal") | (passchunks.loc[(slice(None),), "event"] == "Shot")]
ratedShots[ratedShots.isRebound == 1]

erie = pd.read_csv("https://raw.githubusercontent.com/bigdatacup/Big-Data-Cup-2021/main/hackathon_scouting.csv")

# make column names better
erie.columns = ['gameDate', 'home', 'away', 'period', 'clock',
       'homeSkaters', 'awaySkaters', 'homeGoals',
       'awayGoals', 'team', 'player', 'event', 'X',
       'Y', 'd1', 'd2', 'd3', 'd4',
       'player2', 'X2', 'Y2']

# scale coordinates to be aligned with the NHL, center ice is (0,0)
erie['Y'] = erie['Y'] - 42.5
erie['X'] = erie['X'] - 100
erie['Y2'] = erie['Y2'] - 42.5
erie['X2'] = erie['X2'] - 100
erie

eSOG = erie.loc[erie['d2'] == "On Net"]
erie['shotQuality'] = eSOG.apply(lambda x: isHighDanger(x['X'],x['Y'], x.name, erie), axis = 1)
eSOG = erie.loc[(erie['event'] == "Shot") & (erie['d2'] == "On Net")]
eS = erie.loc[erie['event'] == "Shot"]
eSOGG = erie.loc[(erie['d2'] == "On Net")]
eG = erie.loc[(erie['event'] == "Goal")]
# eHDSOG = eSOG[eSOG['shotQuality'] == 3]
eG

#score all Corsi events
nwhl['shotQuality'] = nwhl.loc[(nwhl['event'] == "Shot") | (nwhl['event'] == "Goal")].apply(lambda x: isHighDanger(x['X'],x['Y'], x.name, nwhl), axis = 1)

"""# Creating Expected Goal Model"""

from sklearn.linear_model import LogisticRegression, LinearRegression
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split

modelDf = ratedShots.set_index('level_0').drop(['index', 'team', 'event', 'isLat', 'isLowHigh', 'lowHighCount', 'latCount',"d2"], axis = 1)
modelDf

"""## Preprocessing"""

y = modelDf['isGoal'].apply(int)
y

ss = StandardScaler()
mm = MinMaxScaler()
X = modelDf.drop(['isGoal', 'clock'], axis = 1)
X[["shotDistance", "shotAngle",]] = ss.fit_transform(X[["shotDistance", "shotAngle",]])
X[["homeSkaters",	"awaySkaters",	"X",	"Y", "timeDiff", "shotQuality"]] = mm.fit_transform(X[["homeSkaters",	"awaySkaters",	"X",	"Y", "timeDiff",  "shotQuality"]])
X['d3'] = X['d3'].apply(lambda x: 1 if x == True else 0)
X['d4'] = X['d4'].apply(lambda x: 1 if x == True else 0)
X.fillna(0, inplace=True) # only NaN's are in isRush and isRebound
X = pd.get_dummies(X) # includes first levels: deflection and on net
X

X_train, X_test, y_train, y_test = train_test_split(X, y , stratify=y, test_size = 0.3,)

y_train[y_train == 1].count()

"""## Model Creation"""

lr = LogisticRegression(class_weight='balanced', multi_class='multinomial', solver='newton-cg', fit_intercept=True)
lr.fit(X_train, y_train)
print(lr.score(X_test, y_test))
lr.predict(X,)[1:10]

LR = LinearRegression()
LR.fit(X_train, y_train)
LR.score(X_train, y_train)
LR.predict(X,)[1:10]

from sklearn.metrics import confusion_matrix

predictions = lr.predict(X_test)
cm = confusion_matrix(y_test, predictions)
plt.figure(figsize=(9,9))
sns.heatmap(cm, annot=True, fmt=".3f", linewidths=.5, square = True, cmap = 'Blues_r');
plt.ylabel('Actual label');
plt.xlabel('Predicted label');
all_sample_title = f'Accuracy Score: {lr.score(X_test, y_test)}'
plt.title(all_sample_title, size = 15);

lr.intercept_[0]

def xGcalc(series, model):
  vec = model.intercept_[0] + ((series.to_numpy() * model.coef_).sum())
  return 1/(1 + np.exp(-vec))

withxG = X.copy()
withxG['xG'] = withxG.apply(lambda x: xGcalc(x, lr), axis = 1)
withxG = withxG[['xG',]]
withxG

data = data.join(withxG,how='left',lsuffix = " ", rsuffix = " ")
data = data.join(ratedShots.set_index('index')[['lowHighCount', 'latCount']], how="left", lsuffix="")
data

"""# Create Chunks"""

rdata = ratedShots.set_index('level_0')
rdata = rdata.join(withxG, how='left', lsuffix = "", rsuffix = "")
rdata

fig, ax = plotIce()
sns.scatterplot(x ='X', y = 'Y', data = rdata[rdata.lowHighCount == 0], ax = ax, hue = 'xG')

"""## Find Power Play Passing"""

# find power play opportunities
PP = rdata[rdata['homeSkaters'] != rdata['awaySkaters']]
PP

lowLat = PP[(PP['lowHighCount'] >= 1) | (PP['latCount'] >= 1)]
lowLat

seperateChunks(data)

chunks = data.reset_index().set_index(['chunk', 'chunkIdx'])
chunks

passIndex = np.array(lowLat.index)
eventAfter = passIndex + 1
# data.iloc[eventAfter].groupby("event").count()[['home']]

chunks_withLatLowIdx = np.unique(np.array(list(zip(*chunks.iloc[passIndex].index))[0]))
# create pandas index slice and access all chunks that contain lat low pass
idx = pd.IndexSlice
chunks_withLatLow = chunks.loc[idx[chunks_withLatLowIdx],:]
chunks_withLatLow

fig, ax = plotIce()
mapPassEvents(chunks.loc[593], fig, ax)

fig, ax = plotIce()
sns.scatterplot(x= 'X', y = 'Y', data = lowLat, ax = ax)
sns.scatterplot(x= 'X2', y = 'Y2', data = lowLat, ax = ax, color = 'red')

n = 890
fig, ax = plotIce()
mapPassEvents(chunks.loc[n], fig, ax)
chunks.loc[n]

for i in chunks_withLatLowIdx[:30]:
  fig, ax = plotIce()
  mapPassEvents(chunks.loc[i], fig, ax)

"""# Exploring Data

"""

# create indexes for low high
lowHighStart = (passes['X'] >= 69)
lowHighEnd = (passes['X2'] <= 44) & (passes['X2'] >= 24)
lowHigh = passes[lowHighStart & lowHighEnd]
# plot to confirm location
fig, ax = plotIce()
sns.scatterplot(x= 'X', y = 'Y', data = lowHigh, ax = ax)
sns.scatterplot(x= 'X2', y = 'Y2', data = lowHigh, ax = ax, color = 'red')
# display data frame
lowHigh

## find all pass attempts (labled as Play)
passes = PP[(PP.event == "Play") | (PP.event == "Incomplete Play")]
# define a "lateral" pass
lateralStart = ((passes['X'] >= 54) & (passes['Y'] <= -22) | (passes['Y'] >= 22)) # check if lateral pass will start in right location
lateralEnd = ((passes['X2'] >= 54) & (passes['Y2'] <= -22) | (passes['Y2'] >= 22)) # check if lateral pass will end in right location
lateral = passes[lateralStart & lateralEnd & (passes['X'] >= 54) & (passes['X2'] >= 54)] # data frame with just lateral passes
# graph start and end location of lateral passes to confirm
fig, ax = plotIce()
sns.scatterplot(x= 'X', y = 'Y', data = lateral, ax = ax)
sns.scatterplot(x= 'X2', y = 'Y2', data = lateral, ax = ax, color = 'red')
# display data frame
lateral

"""# Zone Entries"""

eZoneEntries = erie[erie['event'] == 'Zone Entry'].reset_index()
eZoneEntries.head()

erie[((erie.homeSkaters <= 4) | (erie.awaySkaters <= 4)) & (erie.event == "Shot") & (erie.d2 == "On Net")]

"""# Scoring Chance Regions

# Passing patterns
"""

ePass = erie.loc[(erie['event'] == "Play") | (erie['event'] == "Incomplete Play")]
ePass

fig, ax = plotIce()
colors = {
      'Incomplete Play': 'red',
      'Play': 'blue'
  }
tofP = {
    'Direct': '-',
    'Indirect': '-.'
}

for index, play in ePass.iterrows():
  cColor = colors[play['event']]
  ctype = tofP[play['d1']]
  ax.arrow(play['X'], play['Y'], (play['X2'] - play['X']), (play['Y2'] - play['Y']), head_width=3, linestyle = ctype, color = cColor, width=1, alpha = 0.3,)

"""### Identifying Plays"""

firstPlay = chunks[chunks.index.get_level_values('chunkIdx') == 1]#.reset_index('chunkIdx')
lastPlay = chunks[np.roll(chunks.index.get_level_values('chunkIdx') == 1, -1)]#.reset_index('chunkIdx')
h = lastPlay.reset_index(['chunk', 'chunkIdx'])
h['chunkIdx'] = 2
lastPlay = h.set_index(['chunk', 'chunkIdx'])

a = np.array(list(zip(*chunks[(chunks['awaySkaters'] <= 4) | (chunks['homeSkaters'] <= 4)].index))[0])
ppI = np.unique(a)
ppI[20:30]

type(erie.groupby(["player","event"]).count())

firstLastPlay = pd.concat([firstPlay, lastPlay], axis = 0,).sort_index() #.reset_index().#.set_index(['chunk', 'chunkIdx'])
firstLastPlay

"""#### Breakouts"""

index1 = firstLastPlay.loc[(slice(None), 1), "X"] <= -24
index2 = firstLastPlay.loc[(slice(None), 2), "X"] >= -24
a1 = list(zip(*firstLastPlay.loc[(slice(None), 1),:][index1].index))[0]
b1 = list(zip(*firstLastPlay.loc[(slice(None), 2),:][index2].index))[0]
breakoutI = list(set(a1).intersection(b1))
breakoutI.sort()
breakouts = chunks.loc[breakoutI,:]
breakouts

count = 80
for i in breakoutI:
  fig, ax = plotIce()
  mapPassEvents(breakouts.loc[i], fig, ax)
  count += 1
  if count == 90:
    break

h = lastPlay.reset_index(['chunk', 'chunkIdx'])
h['chunkIdx'] = 2
h.set_index(['chunk', 'chunkIdx'])

